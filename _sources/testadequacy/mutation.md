Mutation Testing
================

## Overview

Mutation Testing propose the creation of variations of the software under test in order that these tests show that these variations are not correct, therefore by elimination it can be verified that the original program is correct, these checks are made based on execution of existing unit tests. With this in mind, we can consider mutation testing as a technique to help in the process of improving test cases, making them more efficient, as well as to improve or guarantee the quality of these test cases, note that the test technique of mutation testing is a white box test technique.

Mutation Testing works in the following way, the mutation operators are used on the original code making small changes on those in order to generate some variations called mutants, hence the name given to the technique. After the mutants have been generated, the tests originally used to test the code are performed on the generated mutants, if these mutants fail the test cases they will be considered ‘killed’ mutants, if any mutant does not fail he is considered a ‘survived’ mutant and this is an indication that the tests need to be reviewed/analyzed, making these tests more efficient after these analyzes and corrections.

Here is an example of a mutation in a given piece of python code:
```python
def summation(*values):
    total = 0
    for i in values:
        total+=i
    return total
```
The Assignment Operator Replacement (ASR) would replace `+=` with `-=` and produce the following mutant:
```python
def summation(*values):
    total = 0
    for i in values:
        total-=i
    return total
```
or other change can be the Constant Replacement (CRP) that would replace `total = 0` with `total = 1` and produce the following mutant:
```python
def summation(*values):
    total = 1
    for i in values:
        total+=i
    return total
```
When the mutants survive the tests, two situations can be considered, the first is when the test cases are not good enough, as they have not identified the changes in the mutants, and the second is the equivalence between the original program and the mutant called Equivalent Mutant, equivalent mutants are one of the major problems in using mutation tests.

For example, let's consider a particular code section of a program *pro*, and we're going to indicate a mutant for that program *mut*. In this case the *mut* is going to be an equivalent mutant if *mut* is syntactically different from *pro* but have the same behavior as *pro*.
```java
//Program pro
for (int i=0; i<10; i++){
    /* i value still the same */
}
```
```java
//Equivalent Mutant mut
for (int i=0; i!=10; i++){
    /* i value still the same */
}
```
The example above shows a mutant that was generated by the Relational Operator Replacement (ROR), which changes the operator  `<` for `!=`, if during the execution of the mutant the loop instruction does not change the value of `i`, in this case both, the program pro and your mutant mut, will produce the same output.

## Mutation Operators

Mutation operators are changes that are made to the original code in order to generate mutants, these changes can be made by modifying expressions by changing, adding or removing operators and/or statements. These operators can be arithmetic, relational, conditional, logical, assignment, among others.

### Examples of Operators Used

#### Structural mutation operators
 * AOD - Arithmetic Operator Deletion
 * AOR - Arithmetic Operator Replacement
 * AOI - Arithmetic Operator Insertion
 * COD - Conditional Operator Deletion
 * COR - Conditional Operator Replacement
 * COI - Conditional Operator Insertion
 * ASR - Assignment Operator Replacement
 * LOD - Logical Operator Deletion
 * LOR - Logical Operator Replacement
 * LOI - Logical Operator Insertion
 * BCR - Break Continue Replacement
 * CRP - Constant Replacement
 * LCR - Logical Connector Replacement
 * ROR - Relational Operator Replacement
 * SOR - Shift Operator Replacement

#### Object-Oriented mutation operators
 * EHD - Exception Handler Deletion
 * EXS - Exception Swallowing
 * IHD - Hiding Variable Deletion
 * IOD - Overriding Method Deletion
 * IOP - Overridden Method Calling Position Change
 * SCD - Super Calling Deletion
 * SCI - Super Calling Insertion

#### Python-related mutation operators
 * DDL - Decorator Deletion
 * SIR - Slice Index Remove

Some of this operators will be shown on 'Hands On: MutPy' section. 

## Pros and Cons

### Pros
 * Creation of effective test suites;
 * Verification of the suite's reliability;
 * Help in refactoring tests;

### Cons
 * The high computational cost;
 * The amount of human effort involved;

## Background

Good materials on Mutation testing can be found in the literature, some of which were used as the basis for the elaboration of this chapter, such as the survey published by [Jia and Harman (2011)](https://ieeexplore.ieee.org/abstract/document/5487526), [Ma and Offutt (2005)](https://courses.cs.ut.ee/MTAT.03.159/2015_spring/uploads/Main/mutopsMethod.pdf) and [Dereziska and Halas (2014)](https://ieeexplore.ieee.org/abstract/document/6825653) publications that also talk about mutation operators, among other works such as those by [Madeyski et al (2014)](https://ieeexplore.ieee.org/abstract/document/6613487), [Frankl et al (1997)](https://www.sciencedirect.com/science/article/pii/S0164121296001549), and [Papadakis et al (2019)](https://www.sciencedirect.com/science/article/pii/S0065245818300305).


Hands On: MutPy
================

 
> [MutPy](https://pypi.org/project/MutPy/) is a mutation testing tool for Python 3.3+ source code. MutPy supports standard unittest module, generates YAML/HTML reports and has colorful output. It applies mutation on AST level. You could boost your mutation testing process with high order mutations (HOM) and code coverage analysis.

## Installing

There is two manners to install the MutPy, you can do this using the PyPi command:

`$ pip install mutpy`
 
Or cloning the MutPy repository to get the latest version available:
```
$ git clone git@github.com:mutpy/mutpy.git
$ cd mutpy/
$ python3 setup.py install
```
Now we have the MutPy installed let's practice a little to check some of the mutants operators working. We will follow the example of the calculator, as it is a very practical example and we can show some of these operators in action with simple examples.

## Examples

To run the examples we will create a file `calculator.py` that will be our main file, and based on this file the MutPy will made the changes to create the mutants files.
```python
def multiplication (x,y):
    return x*y
```
Now we have a main file we also need a test file to cover this code, for this we will create the file `test_calculator.py` with our unittest the check its quality. 
```python
from unittest import TestCase
from calculator import multiplication
 
class MultTest (TestCase):
    def test_Mult(self):
        self.assertEqual(multiplication(2,2),4)
```
Since we have the main code and its unittets, let’s run the MutPy command on the same directory were we have this files and let’s check the outputs that will be shown to us. 

`$ mut.py --target calculator --unit-test test_calculator -m`

Note that the command have some parameters, where --target is our main file (calculator.py) and --unit-test is our test (test_calculator.py)[^1]. After run the command above it will produce the following output.
[^1]: A List of all arguments with which you can run MutPy can be found on their [page](https://pypi.org/project/MutPy/).
```
[*] Start mutation process:
   - targets: calculator
   - tests: test_calculator
[*] 1 tests passed:
   - test_calculator [0.00000 s]
[*] Start mutants generation and execution:
   - [#   1] AOR calculator:
---------------------------------------------------------------------------
  1:
  2: def multiplication(x, y):
- 3:     return x * y
+ 3:     return x / y
---------------------------------------------------------------------------
[0.00100 s] killed by test_Mult (test_calculator.MultTest)
   - [#   2] AOR calculator:
---------------------------------------------------------------------------
  1:
  2: def multiplication(x, y):
- 3:     return x * y
+ 3:     return x // y
---------------------------------------------------------------------------
[0.00100 s] killed by test_Mult (test_calculator.MultTest)
   - [#   3] AOR calculator:
---------------------------------------------------------------------------
  1:
  2: def multiplication(x, y):
- 3:     return x * y
+ 3:     return x ** y
---------------------------------------------------------------------------
[0.00050 s] survived
[*] Mutation score [0.03450 s]: 66.7%
   - all: 3
   - killed: 2 (66.7%)
   - survived: 1 (33.3%)
   - incompetent: 0 (0.0%)
   - timeout: 0 (0.0%)
```
In this example above, 3 mutants were generated, but only 2 were killed and the last one survived, giving to us the score ratio of 66.7% of reliability. One of the generated mutants survived because the result of the assert `2*2 == 4` is exactly the same result of the mutation `2**2 == 4`, so in this case the the test is not good enough to test the multiplication operation, which indicates that we need to change the entries for this test to improve our coverage.
```python
from unittest import TestCase
from calculator import multiplication
 
class MultTest (TestCase):
    def test_Mult(self):
        self.assertEqual(multiplication(2,5),10)
```     
After the changes above and ran the MutPy again we can notice the the same 3 mutants were generated, but on this execution all mutants were killed properly, giving to us the score ratio of 100% of reliability. 
```
[*] Mutation score [0.02900 s]: 100.0%
   - all: 3
   - killed: 3 (100.0%)
   - survived: 0 (0.0%)
   - incompetent: 0 (0.0%)
   - timeout: 0 (0.0%)
```
If you observe on examples above, only one of the mutation operators was used on the 3 mutants, the operator AOR (Arithmetic Operator Replacement). Let’s now check other examples that uses others operators. 

### Arithmetic operators

#### AOD - Arithmetic Operator Deletion

`calculator.py`
```python
def inversion (x):
    return -x
```
`test_calculator.py`
```python
class InvTest (TestCase):
    def test_Inv(self):
        self.assertEqual(inversion(4),-4)
```
`mut.py` output:
```
...
[*] Start mutants generation and execution:
   - [#   1] AOD calculator:
--------------------------------------------------------------------------------
  1:
  2: def inversion(x):
- 3:     return -x
+ 3:     return x
--------------------------------------------------------------------------------
[...]
--------------------------------------------------------------------------------
[0.00150 s] killed by test_Inv (test_calculator.InvTest)
[*] Mutation score [0.02200 s]: 100.0%
   - all: 2
   - killed: 2 (100.0%)
   - survived: 0 (0.0%)
...
```

### Assignment Operators

#### ASR - Assignment Operator Replacement and CRP - Constant Replacement

`calculator.py`
```python
def summation(*values):
    total = 0
    for i in values:
        total+=i
    return total
```
`test_calculator.py`
```python
class SummaTest (TestCase):
    def test_Summa(self):
        self.assertEqual(summation(1,2,3,4),10)
```
`mut.py` output:
```
...
[*] Start mutants generation and execution:
   - [#   1] ASR calculator:
--------------------------------------------------------------------------------
  1:
  2: def summation(*values):
  3:     total = 0
  4:     for i in values:
- 5:         total += i
+ 5:         total -= i
  6:     return total
--------------------------------------------------------------------------------
[0.00050 s] killed by test_Summa (test_calculator.SummaTest)
   - [#   2] CRP calculator:
--------------------------------------------------------------------------------
  1:
  2: def summation(*values):
- 3:     total = 0
+ 3:     total = 1
  4:     for i in values:
  5:         total += i
  6:     return total
--------------------------------------------------------------------------------
[0.00100 s] killed by test_Summa (test_calculator.SummaTest)
[*] Mutation score [0.03350 s]: 100.0%
   - all: 2
   - killed: 2 (100.0%)
   - survived: 0 (0.0%)
...
```

### Conditional Operators

#### COD - Conditional Operator Deletion and COI - Conditional Operator Insertion

`calculator.py`
```python
from numbers import Number
def isNum(x):
    if not isinstance(x,Number):
        return False
    return True
```
`test_calculator.py`
```python
class IsNumTest (TestCase):
    def test_IsNum(self):
        self.assertEqual(isNum(1),True)
```
`mut.py` output:
```
...
[*] Start mutants generation and execution:
   - [#   1] COD calculator:
--------------------------------------------------------------------------------
  1: from numbers import Number
  2:
  3: def isNum(x):
- 4:     if not (isinstance(x, Number)):
+ 4:     if isinstance(x, Number):
  5:         return False
  6:     return True
--------------------------------------------------------------------------------
[0.00200 s] killed by test_IsNum (test_calculator.IsNumTest)
   - [#   2] COI calculator:
--------------------------------------------------------------------------------
  1: from numbers import Number
  2:
  3: def isNum(x):
- 4:     if not (isinstance(x, Number)):
+ 4:     if not ((not (isinstance(x, Number)))):
  5:         return False
  6:     return True
--------------------------------------------------------------------------------
[0.00100 s] killed by test_IsNum (test_calculator.IsNumTest)
[*] Mutation score [0.03200 s]: 100.0%
   - all: 2
   - killed: 2 (100.0%)
   - survived: 0 (0.0%)
...
```

### Relational Operator

#### ROR - Relational Operator Replacement

`calculator.py`
```python
def areEquals(x,y):
    if x == y:
        return True
    return False
```
`test_calculator.py`
```python
class AreEqual (TestCase):
    def test_areEquals(self):
        self.assertEqual(areEquals(9,9),True)
        self.assertEqual(areEquals(4,2),False)
```
`mut.py` output:
```
...
[*] Start mutants generation and execution:
[...]
   - [#   2] ROR calculator:
--------------------------------------------------------------------------------
  1:
  2: def areEquals(x, y):
- 3:     if x == y:
+ 3:     if x != y:
  4:         return True
  5:     return False
--------------------------------------------------------------------------------
[0.00150 s] killed by test_areEquals (test_calculator.AreEqual)
[*] Mutation score [0.02950 s]: 100.0%
   - all: 2
   - killed: 2 (100.0%)
   - survived: 0 (0.0%)
...
```

### Logical Operator

#### LCR - Logical Connector Replacement

`calculator.py`
```python
...
def areNum(x,y):
    if isNum(x) and isNum(y):
        return True
    return False
```
`test_calculator.py`
```python
class AreNumTest (TestCase):
    def test_AreNum(self):
        self.assertEqual(areNum(2,9),True)
        self.assertEqual(areNum('a',8),False)
```
`mut.py` output:
```
...
[*] Start mutants generation and execution:
...
   - [#   4] LCR calculator:
--------------------------------------------------------------------------------
   5:         return False
   6:     return True
   7:
   8: def areNum(x, y):
-  9:     if (isNum(x) and isNum(y)):
+  9:     if (isNum(x) or isNum(y)):
  10:         return True
  11:     return False
--------------------------------------------------------------------------------
[0.00100 s] killed by test_AreNum (test_calculator.AreNumTest)
[*] Mutation score [0.08651 s]: 100.0%
   - all: 4
   - killed: 4 (100.0%)
   - survived: 0 (0.0%)
...
```

As a suggestion, it is good to practice these examples above on your machine and preferably changing your test files to check how much your coverage is being improved or not with these changes.